
public class Itinerary {
	private TripStopNode head;
	private TripStopNode tail;
	private TripStopNode cursor;
	private TripStopNode dummy;// an empty node that only contains 
								//a link to the first link
	private TripStop dummyStop;
	private int size = 0;
	private int totalDist = 0;

	public Itinerary() {
		
		tail = null;
		cursor = null;
		dummyStop = new TripStop("",0,"");
		dummy = new TripStopNode(dummyStop);
		head = dummy;// sets head to static position, called dummy
	}

	public int getStopsCount() {
		return size;
	}

	public int getTotalDistance() {
		return totalDist;
	}

	public void resetCursorToHead() {
		if (dummy != null)
			cursor = dummy;// resets cursor to dummy node
		else
			cursor = null;
	}

	public void cursorFoward() throws EndOfItineraryException
	{
		if (cursor == tail) {
			throw new EndOfItineraryException();
		}
		cursor = cursor.getNext();
	}

	public void cursorBackward() throws EndOfItineraryException {
		if (cursor == null || cursor.getPrev() == dummy ) {
			throw new EndOfItineraryException();
		}
		cursor = cursor.getPrev();
	}

	public void insetBeforeCursor(TripStop newStop) throws IllegalArgumentException
	{
	
	if (newStop == null)//make sure data is present before adding to linked list
	{
		throw new IllegalArgumentException();
	}
	TripStopNode newNode = new TripStopNode(newStop);
	if (cursor == null)//FIX THIS!
	{
		newNode.setPrev(dummy);
		tail = newNode;
		tail.setPrev(dummy);
		dummy.setNext(newNode);
		cursor = newNode;
		//System.out.println("Cursor.getNext = " + cursor.getNext());
		//System.out.println("Cursor = " + cursor);
		
	}
	else if (cursor == dummy)
	{/*
		set newStop's previous as dummy,then sets its next to dummy's next
		this ensures that the linked list is not destroyed from the insertion
		then dummy's next is set to newStop
	*/
		
		newNode.setPrev(dummy);
		newNode.setNext(dummy.getNext());
		if (dummy.getNext()!=null){
			dummy.getNext().setPrev(newNode);
		}
		else {
			dummy.setNext(newNode);
		}
		
		
		cursor = newNode;
		System.out.println("Cursor = " + cursor);
		System.out.println("Cursor.getNext2 = " + cursor.getNext());
		
		if (newNode.getNext() == null)
		{
			tail = newNode;
		}
	}
	
	else
	{
		/*
		 * set newStop's next to current cursor,
		 * set newStop's previous to cursorsPrevious
		 * this again ensures the linked list is not broken
		 * set newStops previous's next value to newStop. 
		 */
		newNode.setNext(cursor);
		newNode.setPrev(cursor.getPrev());
		newNode.getNext().setPrev(newNode);
		newNode.getPrev().setNext(newNode);
		cursor = newNode;
	
		if (newNode.getNext() == null)
		{
			tail = newNode;
		}
	}
	size++;// increment size of linked list
	totalDist += newStop.getDistance();//increment total distance
}

	public void appendToTail(TripStop newStop) throws IllegalArgumentException 
	{
		if (newStop == null) {
			throw new IllegalArgumentException();
		}

		TripStopNode newNode = new TripStopNode(newStop);

		if (tail == null) 
		{
			dummy = newNode;
			tail = newNode;
			cursor = newNode;
		} else 
		{
			tail.setNext(newNode);
			newNode.setPrev(tail);
		}
		size++;// increment size of linked list
		totalDist += newStop.getDistance();// increment total distance
	}
	public TripStop removeCursor() throws EndOfListException
	{
		TripStopNode removedNode = null;
		if (cursor == null)
		{
			throw new EndOfListException();
		}
		if (cursor == dummy)
		{
			cursor = dummy;
			return null;
		}
		if (cursor == tail)
		{
			removedNode = tail;
			System.out.println("C1"+ cursor);
			System.out.println("tail.getPrev() = " + tail.getPrev());
			tail.getPrev().setNext(null);
			tail =tail.getPrev();
			cursor = cursor.getPrev();
			System.out.println("C2" +cursor);
			
			
		}
		else
		{
			/*
			 * set removedNode to current cursor
			 * cursors previous and next values must now be connected
			 * while the value cursor was holding is left for garbage collection
			 * cursor now references previous link
			 */
			removedNode = cursor;
			System.out.println("Removed Node 1= " + removedNode);
			System.out.println("c.gn " + cursor.getNext());
			System.out.println("c.gp " + cursor.getPrev());
			
			cursor.getNext().setPrev(cursor.getPrev());
			cursor.getPrev().setNext(cursor.getNext());
			if (cursor.getPrev() !=dummy){
				System.out.println("hi");
				cursor = cursor.getPrev();
			}
			
			//System.out.println("Cursor = " + cursor);
			//System.out.println("Removed Node = " + removedNode);
		}
		
		
		size--;
		totalDist -= removedNode.getData().getDistance();
		return removedNode.getData();
		
	}
	public Object Clone ()
	{
		Itinerary clonedIt = new Itinerary();
		TripStopNode nodePtr = dummy.getNext();
		while (nodePtr.getNext() != null)
		{
			nodePtr.Clone();
			nodePtr = nodePtr.getNext();
		}
		return clonedIt;
	}
	public void PrintAllStops()
	{
		TripStopNode nodePtr = dummy.getNext();
		//System.out.println(nodePtr);
		//System.out.println(nodePtr.getNext());
		while(nodePtr != null)
		{
			System.out.println(nodePtr);
			nodePtr = nodePtr.getNext();
			
		}
	}
	
	
}